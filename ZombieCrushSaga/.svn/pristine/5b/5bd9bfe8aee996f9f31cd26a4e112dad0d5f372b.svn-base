package ZombieCrushSaga.data;

import ZombieCrushSaga.ui.ZombieCrushSagaTile;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.GregorianCalendar;
import java.util.Iterator;
import ZombieCrushSaga.ZombieCrushSaga.ZombieCrushSagaPropertyType;
import mini_game.MiniGame;
import mini_game.MiniGameDataModel;
import mini_game.SpriteType;
import properties_manager.PropertiesManager;
import static ZombieCrushSaga.ZombieCrushSagaConstants.*;
import ZombieCrushSaga.ui.ZombieCrushSagaMiniGame;
import ZombieCrushSaga.ui.ZombieCrushSagaPanel;
import java.awt.Color;
import java.awt.Toolkit;
import java.awt.image.FilteredImageSource;
import java.awt.image.ImageFilter;
import java.awt.image.ImageProducer;
import java.awt.image.RGBImageFilter;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This class manages the game data for Mahjong Solitaire.
 *
 * @author Richard McKenna
 */
public class ZombieCrushSagaDataModel extends MiniGameDataModel {
    // THIS CLASS HAS A REFERERENCE TO THE MINI GAME SO THAT IT
    // CAN NOTIFY IT TO UPDATE THE DISPLAY WHEN THE DATA MODEL CHANGES
    private int speed;
    private MiniGame miniGame;
    // THE LEVEL GRID REFERS TO THE LAYOUT FOR A GIVEN LEVEL, MEANING
    // HOW MANY TILES FIT INTO EACH CELL WHEN FIRST STARTING A LEVEL
    private int[][] levelGrid;
    private int addOther;
    // LEVEL GRID DIMENSIONS
    private int gridColumns;
    private int gridRows;
    private String selectMove;
    private String selectedMove;
    private boolean startPlaying;
    private ArrayList<int[]> currentNeedToMove;
     private ArrayList<int[]>currentNeedSpeecial;
    // THIS STORES THE TILES ON THE GRID DURING THE GAME
    private ArrayList<ZombieCrushSagaTile>[][] tileGrid;
    // THESE ARE THE TILES THE PLAYER HAS MATCHED
    private ArrayList<ZombieCrushSagaTile> stackTiles;
    //   using to fill
    private ArrayList<ZombieCrushSagaTile> sixTiles;
    //   special tile
    private ArrayList<ZombieCrushSagaTile> specialTiles; // each special 300 tiles total 6*{100 (4)+100(T//L)}+300(5)
    // THESE ARE THE TILES THAT ARE MOVING AROUND, AND SO WE HAVE TO UPDATE
    
    private ArrayList<ZombieCrushSagaTile> movingTiles;
    // THIS IS A SELECTED TILE, MEANING THE FIRST OF A PAIR THE PLAYER
    // IS TRYING TO MATCH. THERE CAN ONLY BE ONE OF THESE AT ANY TIME
    private ZombieCrushSagaTile selectedTile;
    // THE INITIAL LOCATION OF TILES BEFORE BEING PLACED IN THE GRID
    private int unassignedTilesX;
    private int unassignedTilesY;
    // THESE ARE USED FOR TIMING THE GAME
    private GregorianCalendar startTime;
    private GregorianCalendar endTime;
    private GregorianCalendar time;
    private long currentScore;
    private int currentMoves;
    // THE REFERENCE TO THE FILE BEING PLAYED
    private String currentLevel;
    private ArrayList<Integer>emptyCol;
    
    private int HS;
    private boolean stop;
    /**
     * Constructor for initializing this data model, it will create the data
     * structures for storing tiles, but not the tile grid itself, that is
     * dependent of file loading, and so should be subsequently initialized.
     *
     * @param initMiniGame The Mahjong game UI.
     */
    public ZombieCrushSagaDataModel(MiniGame initMiniGame) {
        // KEEP THE GAME FOR LATER
        miniGame = initMiniGame;
        currentScore = 0;
        this.currentMoves=0;
        currentNeedToMove = new ArrayList<int[]>();
        // INIT THESE FOR HOLDING MATCHED AND MOVING TILES
        stackTiles = new ArrayList();
        sixTiles = new ArrayList();
        movingTiles = new ArrayList();
        emptyCol=new ArrayList<Integer>();
        addOther = 0;
        startPlaying=false;
        speed=70;
        stop=false;
    }
    public void setData(int score,int moves){
        this.currentMoves=0;
        this.currentScore=0;
    }
    
    // INIT METHODS - AFTER CONSTRUCTION, THESE METHODS SETUP A GAME FOR USE
    // - initTiles
    // - initTile
    // - initLevelGrid
    // - initSpriteType
    /**
     * This method loads the tiles, creating an individual sprite for each. Note
     * that tiles may be of various types, which is important during the tile
     * matching tests.
     */
    public void initTiles() {
        PropertiesManager props = PropertiesManager.getPropertiesManager();
        String imgPath = props.getProperty(ZombieCrushSagaPropertyType.IMG_PATH);
        int spriteTypeID = 0;
        SpriteType sT;

        // WE'LL RENDER ALL THE TILES ON TOP OF THE BLANK TILE
        String blankTileFileName = props.getProperty(ZombieCrushSagaPropertyType.BLANK_TILE_IMAGE_NAME);
        BufferedImage blankTileImage = miniGame.loadImageWithColorKey(imgPath + blankTileFileName, COLOR_KEY);
        ((ZombieCrushSagaPanel) (miniGame.getCanvas())).setBlankTileImage(blankTileImage);

        // THIS IS A HIGHLIGHTED BLANK TILE FOR WHEN THE PLAYER SELECTS ONE
        String blankTileSelectedFileName = props.getProperty(ZombieCrushSagaPropertyType.BLANK_TILE_SELECTED_IMAGE_NAME);
        BufferedImage blankTileSelectedImage = miniGame.loadImageWithColorKey(imgPath + blankTileSelectedFileName, COLOR_KEY);
        ((ZombieCrushSagaPanel) (miniGame.getCanvas())).setBlankTileSelectedImage(blankTileSelectedImage);



        // AND THEN TYPE C, FOR WHICH THERE ARE 4 OF EACH 
        // THIS IS ANALOGOUS TO THE CHARACTER AND NUMBER TILES IN FLAVORLESS MAHJONG
        ArrayList<String> typeCTiles = props.getPropertyOptionsList(ZombieCrushSagaPropertyType.TYPE_C_TILES);
        int x = (int) Math.random() * 6;

        for (int i = 0; i < typeCTiles.size(); i++) // 100
        {
          //  System.out.println(" i:  " + i);
            String imgFile = imgPath + typeCTiles.get(i);

            sT = initTileSpriteType(imgFile, TILE_SPRITE_TYPE_PREFIX + spriteTypeID);
            if (i == x) {
                for (int j = 0; j < 20; j++) {
                    initTile(sT, TILE_C_TYPE);
                }
            } else {
                for (int j = 0; j < 16; j++) {
                    initTile(sT, TILE_C_TYPE);
                }

            }
            spriteTypeID++;
        }
        this.addOther = 1;
        spriteTypeID = 0;
        for (int i = 0; i < 3000; i++) //  using to fill empty
        {
            int pos = (int) (Math.random() * 6);

            String imgFile = imgPath + typeCTiles.get(pos);
            sT = initTileSpriteType(imgFile, TILE_SPRITE_TYPE_PREFIX + pos);
            initTile(sT, TILE_C_TYPE);
        }
        /*   String imgFile = imgPath + typeCTiles.get(x);
          
         sT = initTileSpriteType(imgFile, TILE_SPRITE_TYPE_PREFIX + spriteTypeID);            
         for (int j = 0; j < 20; j++)
         {
         initTile(sT, TILE_C_TYPE);
         }*/
    }

    /**
     * Helper method for loading the tiles, it constructs the prescribed tile
     * type using the provided sprite type.
     *
     * @param sT The sprite type to use to represent this tile during rendering.
     *
     * @param tileType The type of tile. Note that there are 3 broad categories.
     */
    private void initTile(SpriteType sT, String tileType) {
        // CONSTRUCT THE TILE
        ZombieCrushSagaTile newTile = new ZombieCrushSagaTile(sT, unassignedTilesX, unassignedTilesY, 0, 0, INVISIBLE_STATE, tileType);

        // AND ADD IT TO THE STACK
        if (addOther == 0) {
            stackTiles.add(newTile);
        } else {

            sixTiles.add(newTile);
        }
    }
    public void processWin(){
        int i=Integer.parseInt(this.getCurrentLevel().substring(5));
        
        int score=Level_1_Star[i-1];
        int moves=Level_moves[i-1];
        if(this.currentMoves==moves){
             this.sleep(5);
            if(this.currentScore<score)
                this.endGameAsLoss();
            else
               this.endGameAsWin();
        }
    }
    /**
     * Called after a level has been selected, it initializes the grid so that
     * it is the proper dimensions.
     *
     * @param initGrid The grid distribution of tiles, where each cell specifies
     * the number of tiles to be stacked in that cell.
     *
     * @param initGridColumns The columns in the grid for the level selected.
     *
     * @param initGridRows The rows in the grid for the level selected.
     */
    public void initLevelGrid(int[][] initGrid, int initGridColumns, int initGridRows) {
        // KEEP ALL THE GRID INFO
        levelGrid = initGrid;
        gridColumns = initGridColumns;
        gridRows = initGridRows;

        // AND BUILD THE TILE GRID FOR STORING THE TILES
        // SINCE WE NOW KNOW ITS DIMENSIONS
        tileGrid = new ArrayList[gridColumns][gridRows];
        for (int i = 0; i < gridColumns; i++) {
            for (int j = 0; j < gridRows; j++) {
                // EACH CELL HAS A STACK OF TILES, WE'LL USE
                // AN ARRAY LIST FOR THE STACK
                tileGrid[i][j] = new ArrayList();
            }
        }
        // MAKE ALL THE TILES VISIBLE
        enableTiles(true);
    }

    /**
     * This helper method initializes a sprite type for a tile or set of similar
     * tiles to be created.
     */
    private SpriteType initTileSpriteType(String imgFile, String spriteTypeID) {
        // WE'LL MAKE A NEW SPRITE TYPE FOR EACH GROUP OF SIMILAR LOOKING TILES
        SpriteType sT = new SpriteType(spriteTypeID);
        addSpriteType(sT);

        // LOAD THE ART
        BufferedImage img = miniGame.loadImageWithColorKey(imgFile, COLOR_KEY);
        Image tempImage = img.getScaledInstance(TILE_IMAGE_WIDTH, TILE_IMAGE_HEIGHT, BufferedImage.SCALE_SMOOTH);
        img = new BufferedImage(TILE_IMAGE_WIDTH, TILE_IMAGE_HEIGHT, BufferedImage.TYPE_INT_ARGB);
        img.getGraphics().drawImage(tempImage, 0, 0, null);

        // WE'LL USE THE SAME IMAGE FOR ALL STATES
        sT.addState(INVISIBLE_STATE, img);
        sT.addState(VISIBLE_STATE, img);
        sT.addState(SELECTED_STATE, img);
        sT.addState(INCORRECTLY_SELECTED_STATE, img);
        return sT;
    }

    // ACCESSOR METHODS
    /**
     * Accessor method for getting the level currently being played.
     *
     * @return The level name used currently for the game screen.
     */
    public String getCurrentLevel(){
        return currentLevel;
    }

    public long getCurrentScore() {
        return currentScore;
    }

    public long getCurrentMoves() {
        return currentMoves;
    }

    /**
     * Accessor method for getting the number of tile columns in the game grid.
     *
     * @return The number of columns (left to right) in the grid for the level
     * currently loaded.
     */
    public int getGridColumns() {
        return gridColumns;
    }
  public void setStart(boolean t){
       this.startPlaying=t;
  }
    /**
     * Accessor method for getting the number of tile rows in the game grid.
     *
     * @return The number of rows (top to bottom) in the grid for the level
     * currently loaded.
     */
    public int getGridRows() {
        return gridRows;
    }

    /**
     * Accessor method for getting the tile grid, which has all the tiles the
     * user may select from.
     *
     * @return The main 2D grid of tiles the user selects tiles from.
     */
    public ArrayList<ZombieCrushSagaTile>[][] getTileGrid() {
        return tileGrid;
    }

    public ArrayList<ZombieCrushSagaTile> getSixTiles() {
        return this.sixTiles;
    }

    /**
     * Accessor method for getting the stack tiles.
     *
     * @return The stack tiles, which are the tiles the matched tiles are placed
     * in.
     */
    public ArrayList<ZombieCrushSagaTile> getStackTiles() {
        return stackTiles;
    }

    /**
     * Accessor method for getting the moving tiles.
     *
     * @return The moving tiles, which are the tiles currently being animated as
     * they move around the game.
     */
    public Iterator<ZombieCrushSagaTile> getMovingTiles() {
        return movingTiles.iterator();
    }

    /**
     * Mutator method for setting the currently loaded level.
     *
     * @param initCurrentLevel The level name currently being used to play the
     * game.
     */
    public void setCurrentLevel(String initCurrentLevel) {
        currentLevel = initCurrentLevel;
    }

    /**
     * Used to calculate the x-axis pixel location in the game grid for a tile
     * placed at column with stack position z.
     *
     * @param column The column in the grid the tile is located.
     *
     * @param z The level of the tile in the stack at the given grid location.
     *
     * @return The x-axis pixel location of the tile
     */
    public int calculateTileXInGrid(int column, int z) {
        int cellWidth = TILE_IMAGE_WIDTH;
        float leftEdge = miniGame.getBoundaryLeft();
        return (int) (leftEdge + (cellWidth * column) - (Z_TILE_OFFSET * z));
    }

    /**
     * Used to calculate the y-axis pixel location in the game grid for a tile
     * placed at row with stack position z.
     *
     * @param row The row in the grid the tile is located.
     *
     * @param z The level of the tile in the stack at the given grid location.
     *
     * @return The y-axis pixel location of the tile
     */
    public int calculateTileYInGrid(int row, int z) {
        int cellHeight = TILE_IMAGE_HEIGHT;
        float topEdge = miniGame.getBoundaryTop();
        return (int) (topEdge + (cellHeight * row) - (Z_TILE_OFFSET * z));
    }

    /**
     * Used to calculate the grid column for the x-axis pixel location.
     *
     * @param x The x-axis pixel location for the request.
     *
     * @return The column that corresponds to the x-axis location x.
     */
    public int calculateGridCellColumn(int x) {
        float leftEdge = miniGame.getBoundaryLeft();
        x = (int) (x - leftEdge);
        return x / TILE_IMAGE_WIDTH;
    }

    /**
     * Used to calculate the grid row for the y-axis pixel location.
     *
     * @param y The y-axis pixel location for the request.
     *
     * @return The row that corresponds to the y-axis location y.
     */
    public int calculateGridCellRow(int y) {
        float topEdge = miniGame.getBoundaryTop();
        y = (int) (y - topEdge);
        return y / TILE_IMAGE_HEIGHT;
    }

    // TIME TEXT METHODS
    // - timeToText
    // - gameTimeToText
    /**
     * This method creates and returns a textual description of the timeInMillis
     * argument as a time duration in the format of (H:MM:SS).
     *
     * @param timeInMillis The time to be represented textually.
     *
     * @return A textual representation of timeInMillis.
     */
    public String timeToText(long timeInMillis) {
        // FIRST CALCULATE THE NUMBER OF HOURS,
        // SECONDS, AND MINUTES
        long hours = timeInMillis / MILLIS_IN_AN_HOUR;
        timeInMillis -= hours * MILLIS_IN_AN_HOUR;
        long minutes = timeInMillis / MILLIS_IN_A_MINUTE;
        timeInMillis -= minutes * MILLIS_IN_A_MINUTE;
        long seconds = timeInMillis / MILLIS_IN_A_SECOND;

        // THEN ADD THE TIME OF GAME SUMMARIZED IN PARENTHESES
        String minutesText = "" + minutes;
        if (minutes < 10) {
            minutesText = "0" + minutesText;
        }
        String secondsText = "" + seconds;
        if (seconds < 10) {
            secondsText = "0" + secondsText;
        }
        return hours + ":" + minutesText + ":" + secondsText;
    }

    /**
     * This method builds and returns a textual representation of the game time.
     * Note that the game may still be in progress.
     *
     * @return The duration of the current game represented textually.
     */
    public String gameTimeToText() {
        // CALCULATE GAME TIME USING HOURS : MINUTES : SECONDS
        if ((startTime == null) || (endTime == null)) {
            return "";
        }
        long timeInMillis = endTime.getTimeInMillis() - startTime.getTimeInMillis();
        return timeToText(timeInMillis);
    }
   public void sleep(int i){
       stop=true;
       long time1=System.currentTimeMillis()+i;
       while(System.currentTimeMillis()<time1){
           System.out.println(System.currentTimeMillis());
       }
       stop=false;
   }
    // GAME DATA SERVICE METHODS
    // -enableTiles
    // -findMove
    // -moveAllTilesToStack
    // -moveTiles
    // -playWinAnimation
    // -processMove
    // -selectTile
    // -undoLastMove
    /**
     * This method can be used to make all of the tiles either visible (true) or
     * invisible (false). This should be used when switching between the splash
     * and game screens.
     *
     * @param enable Specifies whether the tiles should be made visible or not.
     */
    public void enableTiles(boolean enable) {
        // PUT ALL THE TILES IN ONE PLACE WHERE WE CAN PROCESS THEM TOGETHER
        moveAllTilesToStack();

        // GO THROUGH ALL OF THEM 
        for (ZombieCrushSagaTile tile : stackTiles) {
            // AND SET THEM PROPERLY
            if (enable) {
                tile.setState(VISIBLE_STATE);
            } else {
                tile.setState(INVISIBLE_STATE);
            }
        }
    }

 

    /**
     * This method moves all the tiles not currently in the stack to the stack.
     */
    public void moveAllTilesToStack() {
        for (int i = 0; i < gridColumns; i++) {
            for (int j = 0; j < gridRows; j++) {
                ArrayList<ZombieCrushSagaTile> cellStack = tileGrid[i][j];
                moveTiles(cellStack, stackTiles);
            }
        }
    }

    /**
     *
     * Is free tile
     */
    private boolean isLegalMove(ZombieCrushSagaTile selectTile) {
        int col = selectTile.getGridColumn();
        int row = selectTile.getGridRow();
        int col1 = selectedTile.getGridColumn();
        int row1 = selectedTile.getGridRow();
        String select = selectTile.getSpriteType().getSpriteTypeID().toString();
        String selected = selectedTile.getSpriteType().getSpriteTypeID().toString();
      
    //    this.currentNeedToMove = new ArrayList<int[]>();
        // check honrizontal
        if (row == row1) {
            if (col + 1 == col1) { //  selected left to right
                if (checkH(select, selected, col, row, col1, row1)) {

                    return true;
                } else {
                    return false;
                }
            }
            if (col == col1 + 1) { // selected right to left
                if (checkH(selected, select, col1, row1, col, row)) {
                    //  this.selectMove="LeftToRight";
                    //   this.selectedMove="RightToLeft";
                    return true;
                } else {
                    return false;
                }

            }

        }
        if (col == col1) { // check vertical
            if (row + 1 == row1) {  // 
                if (checkV(select, selected, col, row, col1, row1)) {
                    //   this.selectMove="DownToDown";
                    //   this.selectedMove="UpToDown";
                    return true;
                } else {
                    return false;
                }

            }
            if (row == row1 + 1) {
                if (checkV(selected, select, col1, row1, col, row)) {
                    //   this.selectedMove="DownToUp";
                    //     this.selectMove="UpToDown";
                    return true;
                } else {
                    return false;
                }

            }

        }
        return false;

    }

    public boolean checkH(String left, String right, int col_L, int row_L, int col_R, int row_R) {
        boolean get = false;
        int leftUp=countUp(left, col_L, row_L);
        int leftDown=countDown(left, col_L, row_L);
        int leftLeft=countLeft(left, col_L, row_L);
        int rightUp=countUp(right, col_R, row_R) ;
        int rightDown=countDown(right, col_R, row_R) ;
        int rightRight=countRight(right, col_R, row_R);
        if (leftUp+leftDown>= 2) {
          //  this.moveDown(left, col_L, row_L);
          //  this.moveUp(left, col_L, row_L);
          //  int pos[] = {col_L, row_L};
         //   if (!this.isContain(pos)) {
        //        this.currentNeedToMove.add(pos);
        //    }

            get = true;
        }
        if (leftLeft >= 2) {
           // this.moveLeft(left, col_L, row_L);
         //   int pos[] = {col_L, row_L};
         //   if (!this.isContain(pos)) {
        //        this.currentNeedToMove.add(pos);
        //    }
            get = true;
        }
        if (rightUp+rightDown>= 2) {
          //  this.moveDown(right, col_R, row_R);
         //   this.moveUp(right, col_R, row_R);
        //    int pos[] = {col_R, row_R};
        //    if (!this.isContain(pos)) {
        //        this.currentNeedToMove.add(pos);
       //     }
            get = true;
        }

        if (rightRight >= 2) {
         //   this.moveRight(right, col_R, row_R);
         //   int pos[] = {col_R, row_R};
         //   if (!this.isContain(pos)) {
        //        this.currentNeedToMove.add(pos);
        //    }
            get = true;
        }

        return get;

    }

    public boolean checkV(String up, String down, int col_U, int row_U, int col_D, int row_D) {
        boolean get = false;
        int upUp=countUp(up, col_U, row_U);
        int upLeft=countLeft(up, col_U, row_U);
        int upRight= countRight(up, col_U, row_U);
        int downDown=countDown(down, col_D, row_D) ;
        int downLeft=countLeft(down, col_D, row_D) ;
        int downRight=countRight(down, col_D, row_D);
        if (upUp >= 2) {
           // int pos[] = {col_U, row_U};
         //   if (!this.isContain(pos)) {
        //        this.currentNeedToMove.add(pos);
       //     }
       //     this.moveUp(up, col_U, row_U);
            get = true;
        }
        if (upLeft +upRight >= 2) {
       //     int pos[] = {col_U, row_U};
       //     if (!this.isContain(pos)) {
      //          this.currentNeedToMove.add(pos);
      //      }
       //     this.moveLeft(up, col_U, row_U);
       //     this.moveRight(up, col_U, row_U);
            get = true;
        }
        if (downDown>= 2) {
         //   int pos[] = {col_D, row_D};
         //   if (!this.isContain(pos)) {
       //         this.currentNeedToMove.add(pos);
       //     }
       //     this.moveDown(down, col_D, row_D);
            get = true;
        }
        if ( downLeft+downRight>= 2) {
         //   int pos[] = {col_D, row_D};
        //    if (!this.isContain(pos)) {
        //        this.currentNeedToMove.add(pos);
       //     }
      //      this.moveLeft(down, col_D, row_D);
      //      this.moveRight(down, col_D, row_D);
            get = true;
        }
        return get;


    }
    public void initialBoard(){
        for(int i=tileGrid.length-1;i>=0;i--){
            for(int j=0;j<tileGrid[0].length;j++){
                while(checkAndCount(tileGrid[i][j].get(0)));{
                     this.clear();
                     this.fillEmptyColumn(i);
            }
            }
        }
    
    }
     //  check each tile and move
    public boolean checkAndCount(ZombieCrushSagaTile tile){
        
        String select=tile.getSpriteType().getSpriteTypeID();
        int col=tile.getGridColumn();
        int row=tile.getGridRow();
        int left=this.countLeft(select, col, row);
        boolean get=false;
        int right=this.countRight(select, col, row);
        int up=this.countUp(select, col, row);
        int down=this.countDown(select, col, row);
        if (up+down>= 2) {
            this.moveDown(select, col, row);
            this.moveUp(select, col, row);
            int pos[] = {col, row};
            if (!this.isContain(pos)) {
                this.currentNeedToMove.add(pos);
            }
            System.out.println("V: move  "+(up+down)+" tiles ");
            get = true;
        }
        if (left+right >= 2) {
            this.moveLeft(select, col, row);
            this.moveRight(select, col, row);
            int pos[] = {col, row};
            if (!this.isContain(pos)) {
                this.currentNeedToMove.add(pos);
            }
            get = true;
              System.out.println("H:  move  "+(left+right)+" tiles ");
        }
        if(get&&this.startPlaying){
           int score= calculateScore(left+right+1)+calculateScore(up+down+1);
            System.out.println(" earn score "+score );
            this.currentScore+=score;
        }
        return get;
    
    }
    public int calculateScore(int length){
        if(length==3)
           return 60;
        if(length==4)
            return 120;
        if(length==5)
           return 200;
       return 0;
    }
    /**
     * This method removes all the tiles in from argument and moves them to
     * argument.
     *
     * @param from The source data structure of tiles.
     *
     * @param to The destination data structure of tiles.
     */
    private void moveTiles(ArrayList<ZombieCrushSagaTile> from, ArrayList<ZombieCrushSagaTile> to) {
        // GO THROUGH ALL THE TILES, TOP TO BOTTOM
        for (int i = from.size() - 1; i >= 0; i--) {
            ZombieCrushSagaTile tile = from.remove(i);

            // ONLY ADD IT IF IT'S NOT THERE ALREADY
            if (!to.contains(tile)) {
                to.add(tile);
            }
        }
    }

    /**
     * This method updates all the necessary state information to process the
     * move argument.
     *
     * @param move The move to make. Note that a move specifies the cell
     * locations for a match.
     */
    public void processMove(ZombieCrushSagaMove move) {
        // REMOVE THE MOVE TILES FROM THE GRID
        ArrayList<ZombieCrushSagaTile> stack1 = tileGrid[move.col1][move.row1];
        ArrayList<ZombieCrushSagaTile> stack2 = tileGrid[move.col2][move.row2];
        ZombieCrushSagaTile tile1 = stack1.remove(stack1.size() - 1);
        ZombieCrushSagaTile tile2 = stack2.remove(stack2.size() - 1);


        // MAKE SURE BOTH ARE UNSELECTED
        tile1.setState(VISIBLE_STATE);
        tile2.setState(VISIBLE_STATE);

        //    float targetX1=tile1.calculateTileXInGrid(, tile2.);
        // SEND THEM TO THE STACK
        tile1.setTarget(TILE_STACK_X + TILE_STACK_OFFSET_X, TILE_STACK_Y + TILE_STACK_OFFSET_Y);
        tile1.startMovingToTarget(speed);
        tile2.setTarget(TILE_STACK_X + TILE_STACK_2_OFFSET_X, TILE_STACK_Y + TILE_STACK_OFFSET_Y);
        tile2.startMovingToTarget(speed);
        stackTiles.add(tile1);
        stackTiles.add(tile2);
        // MAKE SURE THEY MOVE
        movingTiles.add(tile1);
        movingTiles.add(tile2);


        // AND MAKE SURE NEW TILES CAN BE SELECTED
        //  selectedTile = null;   


        // NOW CHECK TO SEE IF THE GAME HAS EITHER BEEN WON OR LOST
    }

    /**
     * count left
     */
    public int countLeft(String tileType, int col, int row) {
        int count = 0;
        int x1 = col - 1;
        while (x1 >= 0) {
            if (tileGrid[x1][row].get(0).getSpriteType().getSpriteTypeID().equals(tileType)) {
                count++;
            } else {
                break;
            }
            x1--;
        }
        return count;
    }

    /**
     * move left
     */
    public void moveLeft(String tileType, int col, int row) {
        int count = 0;
        int x1 = col - 1;
        while (x1 >= 0) {
            if (tileGrid[x1][row].get(0).getSpriteType().getSpriteTypeID().equals(tileType)) {
                int pos[] = {x1, row};
                if (!isContain(pos)) {
                     System.out.println(" add "+tileType+" col "+x1+" row "+row);
                    currentNeedToMove.add(pos);
                }

            } else {
                break;
            }
            x1--;
        }

    }

    /**
     * count right
     */
    public int countRight(String tileType, int col, int row) {
        int count = 0;
        int x1 = col + 1;
        while (x1 < tileGrid.length) {
            if (tileGrid[x1][row].get(0).getSpriteType().getSpriteTypeID().equals(tileType)) {
                count++;
            } else {
                break;
            }
            x1++;
        }
        return count;
    }

    /**
     * move right
     */
    public void moveRight(String tileType, int col, int row) {
        int count = 0;
        int x1 = col + 1;
        while (x1 < tileGrid.length) {
            if (tileGrid[x1][row].get(0).getSpriteType().getSpriteTypeID().equals(tileType)) {
                int pos[] = {x1, row};
                if (!isContain(pos)) {
                       System.out.println(" add "+tileType+" col "+x1+" row "+row);
                    currentNeedToMove.add(pos);
                }
            } else {
                break;
            }
            x1++;
        }

    }

    /**
     * count up
     */
    public int countUp(String tileType, int col, int row) {
        int count = 0;
        int y1 = row - 1;
        while (y1 >= 0) {
            if (tileGrid[col][y1].get(0).getSpriteType().getSpriteTypeID().equals(tileType)) {
                count++;
            } else {
                break;
            }
            y1--;
        }
        return count;
    }

    /**
     * count up
     */
    public void moveUp(String tileType, int col, int row) {
        int count = 0;
        int y1 = row - 1;
        while (y1 >= 0) {
            
            if (tileGrid[col][y1].size() > 0) {
                if (tileGrid[col][y1].get(0).getSpriteType().getSpriteTypeID().equals(tileType)) {
                    int pos[] = {col, y1};
                    if (!isContain(pos)) {
                           System.out.println(" add "+tileType+" col "+col+" row "+y1);
                        currentNeedToMove.add(pos);
                    }
                } else {
                    break;
                }
            }
            y1--;
        }

    }

    /**
     * count down
     */
    public int countDown(String tileType, int col, int row) {
        int count = 0;
        int y1 = row + 1;
        while (y1 < tileGrid.length) {
            if (tileGrid[col][y1].get(0).getSpriteType().getSpriteTypeID().equals(tileType)) {
                count++;
            } else {
                break;
            }
            y1++;
        }
        return count;
    }

    /**
     * count down
     */
    public void moveDown(String tileType, int col, int row) {
        int count = 0;
        int y1 = row + 1;
        while (y1 < tileGrid.length) {
            if (tileGrid[col][y1].get(0).getSpriteType().getSpriteTypeID().equals(tileType)) {
                int pos[] = {col, y1};
                if (!isContain(pos)) {
                     System.out.println(" add "+tileType+" col "+col+" row "+y1);
                    currentNeedToMove.add(pos);
                }
            } else {
                break;
            }
            y1++;
        }

    }

    /**
     * This method attempts to select the selectTile argument. Note that this
     * may be the first or second selected tile. If a tile is already selected,
     * it will attempt to process a match/move.
     *
     * @param selectTile The tile to select.
     */
    public void selectTile(ZombieCrushSagaTile selectTile)  //   改改改改改改改改改改改改改改改改改改改
    {      
        
            // IF IT'S ALREADY THE SELECTED TILE, DESELECT IT
            if (selectTile == selectedTile) {
                selectedTile = null;
                selectTile.setState(VISIBLE_STATE);
                return;
            }
            if (selectedTile == null) {
                selectedTile = selectTile;
                selectedTile.setState(SELECTED_STATE);
                return;
            } else {

                if (!selectedTile.match(selectTile)) {
                  //  System.out.println(" before " + this.selectMove + " col:    " + selectTile.getGridColumn() + " row: " + selectTile.getGridRow() + " " + selectTile.getSpriteType().getSpriteTypeID());
                //    System.out.println(" before " + this.selectedMove + " col:    " + selectedTile.getGridColumn() + " row: " + selectedTile.getGridRow() + " " + selectedTile.getSpriteType().getSpriteTypeID());
                    Exchange(selectedTile, selectTile); // change them first       

                    if (this.isLegalMove(selectTile)) {
                            this.currentMoves++;
                        // MAKE SURE BOTH ARE UNSELECTED
                        //   tile2.setState(VISIBLE_STATE);

                        //      this.getMove(selectTile);

                        //        this.getMove(selectedTile);
                   System.out.println(this.currentNeedToMove.size() + " size  start move  ");
                    /*     this.emptyCol=new ArrayList<Integer>();
                        clear();
                        for (int i = 0; i < tileGrid.length; i++) {
                            fillEmptyColumn(i);
                         //  this.emptyCol.add(i);  // fill empty col and get renew column
                        }
                        boolean find=false;
                      //  while(!emptyCol.isEmpty()){   // check renew col
                           
                            for(int i=0;i<tileGrid.length;)
                            for(int j=tileGrid[0].length-1;j>=0;){  // from bottom to top
                                find=false;
                                 while(this.checkAndCount(tileGrid[i][j].get(0))){
                                     this.clear();
                                     for (int k= 0; k < tileGrid.length; k++) {
                                         if(fillEmptyColumn(k))
                                         this.emptyCol.add(k);
                                        }
                                     find=true;
                                 }
                                 if(find){
                                     i=0;
                                     j=tileGrid[0].length-1;
                                 }else{
                                     j--;
                                     i++;
                                 }
                            }*/
                  // clear();
                  //      for (int i = 0; i < tileGrid.length; i++) {
                  //          fillEmptyColumn(i);
                         //  this.emptyCol.add(i);  // fill empty col and get renew column
                //        }
                   
                       this.currentNeedToMove = new ArrayList<int[]>();
                      //    for(int i=0;i<tileGrid.length;i++)
                      //       for(int j=tileGrid[0].length-1;j>=0;j--)
                                 checkAndCount(tileGrid[selectedTile.getGridColumn()][selectedTile.getGridRow()].get(0));
                                  checkAndCount(tileGrid[selectTile.getGridColumn()][selectTile.getGridRow()].get(0));
                        System.out.println(this.currentNeedToMove.size() + " size  start move check ");
                         this.emptyCol=new ArrayList<Integer>();
                         clear();
                    
                       //  this.clearCol(1);
                    //     this.clearRow(2);
                        for (int i = 0; i < tileGrid.length; i++) {
                            fillEmptyColumn(i);
                         
                           this.emptyCol.add(i);  // fill empty col and get renew column
                         //     this.sleep(3);
                        }
                        boolean find=false;
                        while(!emptyCol.isEmpty()){   // check renew col
                            int ecol=emptyCol.remove(0);
                            for(int j=tileGrid[0].length-1;j>=0;){  // from bottom to top
                                find=false;
                                 while(this.checkAndCount(tileGrid[ecol][j].get(0))){
                                     this.clear();
                                       // this.sleep(3);
                                     for (int k= 0; k < tileGrid.length; k++) {
                                         if(fillEmptyColumn(k))
                                         this.emptyCol.add(k);
                                        //    this.sleep(3);
                                        }
                                     this.sleep(1);
                                     find=true;
                                 }
                                 if(find){
                                     j=tileGrid[0].length-1;
                                 }else
                                     j--;
                            }
                     //   this.sleep(1);
                        }
                        
                     //   }
                       
                        selectTile.setState(VISIBLE_STATE);
                        selectedTile.setState(VISIBLE_STATE);
                        selectedTile = null;
                        selectTile = null;
                          
                    } else {
                        Exchange(selectedTile, selectTile);// move back

                        selectTile.setState(VISIBLE_STATE);
                        selectedTile.setState(VISIBLE_STATE);
                        selectedTile = null;
                        selectTile = null;
                    }
                                  
                } else {
                    selectTile.setState(VISIBLE_STATE);
                    selectedTile.setState(VISIBLE_STATE);
                    selectedTile = null;
                    selectTile = null;

                }

            }
         
     
          //   check win
       
    }
    public void clear(){
        
         while(this.currentNeedToMove.size()!=0){
                        ArrayList<ZombieCrushSagaTile> stack = tileGrid[currentNeedToMove.get(0)[0]][currentNeedToMove.get(0)[1]];
                   //     System.out.println(" moves : " + (i + 1) + "  " + currentNeedToMove.get(i)[0] + "   " + currentNeedToMove.get(i)[1]);
                        System.out.print(" , "+stack.get(0).getSpriteType().getSpriteTypeID());
                        stack.remove(stack.size() - 1);
                        currentNeedToMove.remove(0);
                    }
         System.out.println();
    
    }
    public void clearCol(int col){
        for(int i=0;i<tileGrid[col].length;i++){
        ArrayList<ZombieCrushSagaTile> stack = tileGrid[col][i];                  
        stack.remove(stack.size() - 1);
        }
    
    }
    public void clearRow(int row){
         for(int i=0;i<tileGrid.length;i++){
        ArrayList<ZombieCrushSagaTile> stack = tileGrid[i][row];                  
        stack.remove(stack.size() - 1);
        }
    
    }
    /**
     * left right exchange
     */
    public void Exchange(ZombieCrushSagaTile selectTile, ZombieCrushSagaTile selectedTile) {
        //  before change set  seted


        ZombieCrushSagaMove move = new ZombieCrushSagaMove();
        move.col1 = selectTile.getGridColumn();
        move.col2 = selectedTile.getGridColumn();
        move.row1 = selectTile.getGridRow();
        move.row2 = selectedTile.getGridRow();
        processMove(move);

        MovingAnimotion();

       
        //        return true;
        //  }
        //  return false;
    }

    /**
     * This method undoes the previous move, sending the two tiles on top of the
     * tile stack back to the game grid.
     */
    public void MovingAnimotion() {
        if (inProgress() && stackTiles.size() > 1) {
            // TAKE THE TOP 2 TILES
            ZombieCrushSagaTile topTile = stackTiles.remove(stackTiles.size() - 1);
            ZombieCrushSagaTile nextToTopTile = stackTiles.remove(stackTiles.size() - 1);

            // SET THEIR DESTINATIONS
            float boundaryLeft = miniGame.getBoundaryLeft();
            float boundaryTop = miniGame.getBoundaryTop();




            // FIRST TILE 1
            int col = topTile.getGridColumn();
            int row = topTile.getGridRow();

            int col1 = nextToTopTile.getGridColumn();
            int row1 = nextToTopTile.getGridRow();


            int z = tileGrid[col][row].size();
            float targetX = this.calculateTileXInGrid(col1, z);
            float targetY = this.calculateTileYInGrid(row1, z);

            int z1 = tileGrid[col][row].size();
            int targetX1 = this.calculateTileXInGrid(col, z);
            int targetY1 = this.calculateTileYInGrid(row, z);
            topTile.setGridCell(col1, row1);
            topTile.setTarget(targetX, targetY);
            nextToTopTile.setTarget(targetX1, targetY1);
            topTile.setState(VISIBLE_STATE);
            movingTiles.add(topTile);
            topTile.startMovingToTarget(speed);
            tileGrid[col1][row1].add(topTile);

            // AND THEN TILE 2

            nextToTopTile.setGridCell(col, row);
            nextToTopTile.setState(VISIBLE_STATE);
            movingTiles.add(nextToTopTile);
            nextToTopTile.startMovingToTarget(speed);

            tileGrid[col][row].add(nextToTopTile);

        }
    }

    public void moveDownOneStep(ZombieCrushSagaTile tile) {
        if (tile.getGridRow() == tileGrid[0].length - 1) {
            return;
        }
        if (tileGrid[tile.getGridColumn()][tile.getGridRow() + 1].size() == 0) {

            // REMOVE THE MOVE TILES FROM THE GRID
            ArrayList<ZombieCrushSagaTile> stack1 = tileGrid[tile.getGridColumn()][tile.getGridRow()];
            ArrayList<ZombieCrushSagaTile> stack2 = tileGrid[tile.getGridColumn()][tile.getGridRow() + 1];
            ZombieCrushSagaTile tile1 = stack1.remove(stack1.size() - 1); // move tile to tile down 1

            //    float targetX1=tile1.calculateTileXInGrid(, tile2.);
            // SEND THEM TO THE STACK
            tile1.setTarget(TILE_STACK_X + TILE_STACK_OFFSET_X, TILE_STACK_Y + TILE_STACK_OFFSET_Y);
            tile1.startMovingToTarget(speed);
            stackTiles.add(tile1);
            // MAKE SURE THEY MOVE
            movingTiles.add(tile1);
            ZombieCrushSagaTile topTile = stackTiles.remove(stackTiles.size() - 1);
            // SET THEIR DESTINATIONS
            float boundaryLeft = miniGame.getBoundaryLeft();
            float boundaryTop = miniGame.getBoundaryTop();




            // FIRST TILE 1
            int col = topTile.getGridColumn();
            int row = topTile.getGridRow();
            // target pos
            int col1 = topTile.getGridColumn();;
            int row1 = topTile.getGridRow() + 1;


            int z = tileGrid[col][row].size();
            float targetX = this.calculateTileXInGrid(col1, z);
            float targetY = this.calculateTileYInGrid(row1, z);

            topTile.setGridCell(col1, row1);
            topTile.setTarget(targetX, targetY);
            topTile.setState(VISIBLE_STATE);
            movingTiles.add(topTile);
            topTile.startMovingToTarget(speed);
            tileGrid[col1][row1].add(topTile);
        }

    }
    ///  fill empty row 

    public boolean fillEmptyColumn(int col) {
        boolean fill = true;
        boolean get=false;
       
        while (fill) {
            fill = false;
            for (int i = tileGrid[0].length - 1; i >= 0; i--) {
                if (tileGrid[col][i].size() == 1 && i != tileGrid[0].length - 1) {
                    ZombieCrushSagaTile currentTile = tileGrid[col][i].get(0);
                    if (tileGrid[col][i + 1].size() == 0) {
                        moveDownOneStep(currentTile);
                        fill = true;
                        get=true;
                    }
                }
            }
            if (tileGrid[col][0].size() == 0) {
                ArrayList<ZombieCrushSagaTile> stack2 = tileGrid[col][0];
                ZombieCrushSagaTile tile1 = sixTiles.remove(0);
                int z = stack2.size();
                float targetX = this.calculateTileXInGrid(col, z);
                float targetY = this.calculateTileYInGrid(0, z);
                tile1.setX(targetX);
                tile1.setY(targetY - 80);

                //    tile1.setGridCell(col, 0);
                //      System.out.println(" "+tile1.getSpriteType().getSpriteTypeID());
                tile1.setState(VISIBLE_STATE);
                tile1.setGridCell(col, 0);
                tile1.setTarget(targetX, targetY);
                tile1.setState(VISIBLE_STATE);
                movingTiles.add(tile1);
                tile1.startMovingToTarget(speed);
                System.out.println(" fill top ");
                tileGrid[col][0].add(tile1);
                fill = true;
                get=true;

            }

        }
        return get;

    }

    public boolean isContain(int[] pos) {
        for (int i = 0; i < this.currentNeedToMove.size(); i++) {
            if (currentNeedToMove.get(i)[0] == pos[0] && currentNeedToMove.get(i)[1] == pos[1]) {
                return true;
            }
        }
        return false;

    }

    //  running move
    /**
     *
     * move all match
     */
    private void getMove(ZombieCrushSagaTile tile) {
        int col = tile.getGridColumn();
        int row = tile.getGridRow();
        String select = tile.getSpriteType().getSpriteTypeID().toString();
        // check honrizontal
        boolean get = false;
        if (this.countRight(select, col, row) >= 2) {
            this.moveRight(select, col, row);
            get = true;
        }


        if (this.countLeft(select, col, row) >= 2) {
            this.moveLeft(select, col, row);
            get = true;
        }


        if (this.countUp(select, col, row) >= 2) {
            this.moveUp(select, col, row);
            get = true;
        }


        if (this.countDown(select, col, row) >= 2) {
            this.moveDown(select, col, row);
            get = true;
        }

        if (this.countDown(select, col, row) + this.countUp(select, col, row) >= 2) {
            this.moveDown(select, col, row);
            this.moveUp(select, col, row);
            get = true;
        }
        if (this.countLeft(select, col, row) + this.countRight(select, col, row) >= 2) {
            this.moveLeft(select, col, row);
            this.moveRight(select, col, row);
            get = true;
        }
        int[] pos = {col, row};
        if (get) {
            if (!this.isContain(pos)) 
                currentNeedToMove.add(pos);
            
        }
        //   if(move){
        //    ArrayList<ZombieCrushSagaTile> stack = tileGrid[col][row];              
        //      stack.remove(stack.size()-1);
        //       }

    }
    // OVERRIDDEN METHODS
    // - checkMousePressOnSprites
    // - endGameAsWin
    // - endGameAsLoss
    // - reset
    // - updateAll
    // - updateDebugText

    /**
     * This method provides a custom game response for handling mouse clicks on
     * the game screen. We'll use this to close game dialogs as well as to
     * listen for mouse clicks on grid cells.
     *
     * @param game The Mahjong game.
     *
     * @param x The x-axis pixel location of the mouse click.
     *
     * @param y The y-axis pixel location of the mouse click.
     */
    @Override
    public void checkMousePressOnSprites(MiniGame game, int x, int y) {
        // FIGURE OUT THE CELL IN THE GRID
        int col = calculateGridCellColumn(x);
        int row = calculateGridCellRow(y);
        /*    
         // DISABLE THE STATS DIALOG IF IT IS OPEN
         if (game.getGUIDialogs().get(STATS_DIALOG_TYPE).getState().equals(VISIBLE_STATE))
         {
         game.getGUIDialogs().get(STATS_DIALOG_TYPE).setState(INVISIBLE_STATE);
         return;
         }*/

        // CHECK THE TOP OF THE STACK AT col, row
        ArrayList<ZombieCrushSagaTile> tileStack = tileGrid[col][row];
        if (tileStack.size() > 0) {
            // GET AND TRY TO SELECT THE TOP TILE IN THAT CELL, IF THERE IS ONE
            ZombieCrushSagaTile testTile = tileStack.get(tileStack.size() - 1);
            if (testTile.containsPoint(x, y)) {
                    if(!stop){
                  if(Level_moves[Integer.parseInt(this.getCurrentLevel().substring(5))-1]==this.currentMoves)
                      processWin();
                  else
                    
                    selectTile(testTile);
                    }
             

            }
        }
    }

    /**
     * Called when the game is won, it will record the ending game time, update
     * the player record, display the win dialog, and play the win animation.
     */
    @Override
    public void endGameAsWin() {
        // UPDATE THE GAME STATE USING THE INHERITED FUNCTIONALITY
        
        long gameTime = endTime.getTimeInMillis() - startTime.getTimeInMillis();
        ((ZombieCrushSagaMiniGame)miniGame).getPlayerRecord().addWin(currentLevel, currentScore);
        ((ZombieCrushSagaMiniGame)miniGame).savePlayerRecord();
        super.endGameAsWin();
    }

    /**
     *
     * Called when the game is loss, it will record the ending game time, update
     * the player record, display the loss dialog.
     *
     */
    @Override
    public void endGameAsLoss() {
       
        long gameTime = endTime.getTimeInMillis() - startTime.getTimeInMillis();
        ((ZombieCrushSagaMiniGame)miniGame).getPlayerRecord().addLoss(currentLevel);
        
        ((ZombieCrushSagaMiniGame)miniGame).savePlayerRecord();
        
         super.endGameAsLoss();



    }

    /**
     * Called when a game is started, the game grid is reset.
     *
     * @param game
     */
    @Override
    public void reset(MiniGame game) {

        // AND START ALL UPDATES
         
        this.startPlaying=false;
        this.speed=80;
        moveAllTilesToStack();
        for (ZombieCrushSagaTile tile : stackTiles) {
            tile.setX(TILE_STACK_X);
            tile.setY(TILE_STACK_Y);
            tile.setState(VISIBLE_STATE);

        }

        // RANDOMLY ORDER THEM
        Collections.shuffle(stackTiles);

        // START THE CLOCK
        startTime = new GregorianCalendar();

        // NOW LET'S REMOVE THEM FROM THE STACK
        // AND PUT THE TILES IN THE GRID        
        for (int i = 0; i < gridColumns; i++) {
            for (int j = 0; j < gridRows; j++) {
                for (int k = 0; k < levelGrid[i][j]; k++) {
                    // TAKE THE TILE OUT OF THE STACK
                    ZombieCrushSagaTile tile = stackTiles.remove(stackTiles.size() - 1);

                    // PUT IT IN THE GRID
                    tileGrid[i][j].add(tile);
                    tile.setGridCell(i, j);

                    // WE'LL ANIMATE IT GOING TO THE GRID, SO FIGURE
                    // OUT WHERE IT'S GOING AND GET IT MOVING
                    float x = calculateTileXInGrid(i, k);
                    float y = calculateTileYInGrid(j, k);
                    tile.setTarget(x, y);
                    tile.startMovingToTarget(speed);
                    movingTiles.add(tile);
                }
            }
        }
       
        this.currentNeedToMove = new ArrayList<int[]>();
                     for(int i=0;i<tileGrid.length;i++)
                         for(int j=tileGrid[0].length-1;j>=0;j--)
                             checkAndCount(tileGrid[i][j].get(0));
                     this.emptyCol=new ArrayList<Integer>();
                     clear();
                    for (int i = 0; i < tileGrid.length; i++) {
                        fillEmptyColumn(i);
                       this.emptyCol.add(i);  // fill empty col and get renew column
                    }
                    boolean find=false;
                    while(!emptyCol.isEmpty()){   // check renew col
                        int ecol=emptyCol.remove(0);
                        for(int j=tileGrid[0].length-1;j>=0;){  // from bottom to top
                            find=false;
                             while(this.checkAndCount(tileGrid[ecol][j].get(0))){
                                 this.clear();
                                 for (int k= 0; k < tileGrid.length; k++) {
                                     if(fillEmptyColumn(k))
                                     this.emptyCol.add(k);
                                    }
                                 find=true;
                                  
                             }
                             if(find){
                                 j=tileGrid[0].length-1;
                             }else
                                 j--;
                        }
                    
                    }
        // AND START ALL UPDATES
        beginGame();
        this.speed=3;
           this.startPlaying=true;
        // CLEAR ANY WIN OR LOSS DISPLAY
        //    miniGame.getGUIDialogs().get(WIN_DIALOG_TYPE).setState(INVISIBLE_STATE);
        //    miniGame.getGUIDialogs().get(LOSS_DIALOG_TYPE).setState(INVISIBLE_STATE);
        //    miniGame.getGUIDialogs().get(STATS_DIALOG_TYPE).setState(INVISIBLE_STATE);

//        miniGame.getGUIDialogs().get(STATS_DIALOG_TYPE).setState(INVISIBLE_STATE);
    }

    /**
     * Called each frame, this method updates all the game objects.
     *
     * @param game The Mahjong game to be updated.
     */
    @Override
    public void updateAll(MiniGame game) {
        // MAKE SURE THIS THREAD HAS EXCLUSIVE ACCESS TO THE DATA
        try {
            game.beginUsingData();

            // WE ONLY NEED TO UPDATE AND MOVE THE MOVING TILES
            for (int i = 0; i < movingTiles.size(); i++) {
                // GET THE NEXT TILE
                ZombieCrushSagaTile tile = movingTiles.get(i);

                // THIS WILL UPDATE IT'S POSITION USING ITS VELOCITY
                tile.update(game);

                // IF IT'S REACHED ITS DESTINATION, REMOVE IT
                // FROM THE LIST OF MOVING TILES
                if (!tile.isMovingToTarget()) {
                    movingTiles.remove(tile);
                }
            }

            // IF THE GAME IS STILL ON, THE TIMER SHOULD CONTINUE
            if (inProgress()) {
                // KEEP THE GAME TIMER GOING IF THE GAME STILL IS
                endTime = new GregorianCalendar();
            }
        } finally {
            // MAKE SURE WE RELEASE THE LOCK WHETHER THERE IS
            // AN EXCEPTION THROWN OR NOT
            game.endUsingData();
        }
    }

    /**
     * This method is for updating any debug text to present to the screen. In a
     * graphical application like this it's sometimes useful to display data in
     * the GUI.
     *
     * @param game The Mahjong game about which to display info.
     */
    @Override
    public void updateDebugText(MiniGame game) {
    }
}